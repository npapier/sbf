# GLE - Copyright (C) 2005, Nicolas Papier.
# Distributed under the terms of the GNU General Public License (GPL)
# as published by the Free Software Foundation.
# Author Nicolas Papier

# Installation : 
# Python 2.3 and up
# SCons 0.96.1 and up
# SCONS_BUILD_FRAMEWORK environment variable must be defined and set with to the SConsBuildFramework root directory (SCONS_BUILD_FRAMEWORK=D:\SConsBuildFramework\)
#
# Features :
# - targets checkVersion,
# - and myproject_build, myproject_install, myproject(idem myproject_install), myproject_clean, myproject_mrproper
# - and special targets build (for all myproject_build), install (for all myproject_install), all (for all myproject), clean (for all myproject_clean), mrproper (for all myproject_mrproper)
# - default target = all
# - build objects outside sources directories.
# - projects dependencies (deps could be specified with name of project(search in ..), or absolute path or relative path).
# - ...
#
# Rqs: 
# - spaces in target name are prohibited.
# - local*, config and warningLevel are not used in default.options (only in SConsBuildFramework.options)
# ...
#
# Developper comments:
# - MY_PROJECT for internal use only.



###### ######
import fnmatch
import os
import re
import string
import sys

from SCons.Script.SConscript import SConsEnvironment
#import DumpEnv



###### Searching files in a filesystem ######
# Prune some directories
# Exclude/retain only a specific set of extensions for files
def searchFiles( searchDirectory, pruneDirectories, allowedExtensions, oFiles ) :
	for dirpath, dirnames, filenames in os.walk( searchDirectory, topdown=True ):
		# prune directories
		prune = []
		for pruneDirectory in pruneDirectories :
			prune.extend( fnmatch.filter(dirnames, pruneDirectory) )
		for x in prune:
			###print 'prune', x
			dirnames.remove( x )

		for file in filenames:
			for extension in allowedExtensions :
				if ( os.path.splitext(file)[1] == extension ) :
					pathfilename = os.path.join(dirpath,file)
					oFiles += [pathfilename]
					break

	###print 'oFiles=', oFiles



###### Action function for checkVersion target #######
def printCheckMessage(target = None, source = None, env = None) :
	print '----------------------- Check version -----------------------'

def checkCC(target = None, source = None, env = None) :
	if ( env['CC'] == 'cl' ) :
		#ccVersionAction		= Action( 'cl /help' )
		print env['CC'], ' --version '
		print 'cl ', env['MSVS']['VERSION']
	else :
		ccVersionAction		= Action( env['CC'] + ' -v' )
		env.Execute( ccVersionAction )


###### Print action function ######
def nopAction(target = None, source = None, env = None) :
	return 0

def printEmptyLine(target = None, source = None, env = None) :
	print ''

def printBuild( target, source, localenv ) :
	return "----------------------- Build %s -----------------------" % localenv['MY_PROJECT']

def printInstall( target, source, localenv ) :
	return "-------------- Install %s files to %s ------------" % (localenv['MY_PROJECT'], localenv.sbf.myInstallDirectory)

def printClean( target, source, localenv ) :
	return "-------------- Clean %s files to %s ------------" % (localenv['MY_PROJECT'], localenv.sbf.myInstallDirectory)

def printMrproper( target, source, localenv ) :
	return "-------------- Mrproper %s files to %s ------------" % (localenv['MY_PROJECT'], localenv.sbf.myInstallDirectory)


###### SConsBuildFramework class ######

class SConsBuildFramework :

	# global attributes from command line
	myBuildTargets						= []
	#myGHasCleanOption				= False

	# global attributes from SConsBuildFramework.options
	myLocal								= []
	myBuildPath							= ''
	myConfig								= ''													### TODO: []
	myWarningLevel						= ''

	# globals attributes
	myInstallDirectory				= ''
	myPlatform							= ''
	myCC									= ''
	myPlatform_myCC					= ''
	myGCppPath							= []
	myGLibPath							= []

	# project local attributes from default.options
	myDefines							= []
	myType								= ''
	myPostfix							= ''
	myDeps								= []
	myUses								= []
	myLibs								= []
	myStdlibs							= []

	# project local attributes
	myProjectPathName					= ''
	myProjectPath						= ''	
	myProject							= ''
	myProjectBuildPath				= ''
	myPostfixLinkedToMyConfig		= ''

	myCxxFlags							= ''
	myCppPath							= []
	myLinkFlags							= ''
	myLibPath							= []

	myProjectBuildPathExpanded		= ''

	# list of projects that have been already parsed by scons
	myParsedProjects					= []


	###### Constructor ######
	def __init__(self) :
		#
		myOptions = self.readOptions( os.getenv('SCONS_BUILD_FRAMEWORK') + 'SConsBuildFramework.options' )
		myOptions.Update( env )
		Help( myOptions.GenerateHelpText(env) )

		#
		self.initializeGlobalsFromEnv( env )


	###### Initialize global attributes ######
	def initializeGlobalsFromEnv( self, lenv ) :

		###
		self.myBuildTargets = map(str, BUILD_TARGETS)

		# force clean=1 option if needed.
		if (	('clean' in self.myBuildTargets) or
				('mrproper' in self.myBuildTargets) ) :
			if ( len(self.myBuildTargets) != 1 ) :
				print 'myError: only one target allowed when using special target clean or mrproper'
				Exit( 1 )
			else :
				env.SetOption('clean', 1)

		#self.myGHasCleanOption = env.GetOption('clean')

		# update myLocal and myInstallDirectory
		if		( sys.platform == 'win32' ) :
			self.myLocal = lenv['localWin32']
		elif	( sys.platform == 'cygwin' ) :
			self.myLocal = lenv['localCygwin']
		elif	( string.find( sys.platform, 'linux' ) != -1 ) :
			self.myLocal = lenv['localLinux']
		elif	( sys.platform == 'darwin' ) :
			self.myLocal = lenv['localDarwin']
		else :
			self.myLocal = lenv['local']

		if ( len(self.myLocal) >= 1 ) :
			self.myInstallDirectory	= self.myLocal[0]
		else :
			print 'myError: empty localPLATFORM or local'
			sys.exit()

		# update myBuildPath, myConfig and myWarning
		self.myBuildPath			= lenv['buildPath']
		self.myConfig				= lenv['config']
		self.myWarningLevel		= lenv['warningLevel']

		# myPlatform, myCC and myPlatform_myCC
		# myPlatform = win32 | cygwin ? | posix | darwin									FIXME: posix != linux or cygwin or bsd ?, lenv['PLATFORM'] != sys.platform => TOTHINK
		self.myPlatform			= lenv['PLATFORM']

		# myCC = clX-Y | gcc | lenv['CC']
		if		( lenv['CC'] == 'cl' ) :
			self.myCC = 'cl' + lenv['MSVS_VERSION'].replace('.','-')
		elif	( lenv['CC'] == 'g++') :
			self.myCC = 'gcc'
		else :
			self.myCC = lenv['CC']

		self.myPlatform_myCC = '_' + self.myPlatform + '_' + self.myCC

		### use myLocal to update myGCppPath ###
		self.myGCppPath = []
		for element in self.myLocal :
			self.myGCppPath	+= [element + os.sep + 'include']
			self.myGCppPath	+= [element + 'Ext' + self.myPlatform_myCC + os.sep + 'include']

		### use myLocal to update myGLibPath ###
		self.myGLibPath = []
		for element in self.myLocal :
			self.myGLibPath	+=	[element + os.sep + 'lib']
			self.myGLibPath	+=	[element + 'Ext' + self.myPlatform_myCC + os.sep + 'lib']


	###### Initialize project from lenv ######
	def initializeProjectFromEnv( self, lenv ) :
		self.myDefines			= lenv['defines']
		self.myType				= lenv['type']
		self.myPostfix			= lenv['postfix']
		self.myDeps				= lenv['deps']
		self.myUses				= lenv['uses']
		self.myLibs				= lenv['libs']
		self.myStdlibs			= lenv['stdlibs']


	###### Initialize project ######
	def initializeProject( self, projectPathName ) :

		self.myProjectPathName	= projectPathName
		self.myProjectPath		= os.path.dirname( projectPathName )
		self.myProject				= os.path.basename(projectPathName)
		if ( os.path.isabs(self.myBuildPath) ) :
			self.myProjectBuildPath = os.path.abspath( self.myBuildPath )
		else :
			self.myProjectBuildPath = os.path.join( self.myProjectPathName, self.myBuildPath )

		if ( self.myConfig == 'debug' ) :										### TODO: not good if more than one config could be built
			self.myPostfixLinkedToMyConfig = '_D'
		else : 
			self.myPostfixLinkedToMyConfig = ''

		###
		self.myCxxFlags	= ''
		self.myCppPath		= [self.myProjectPathName + os.sep + 'include'] + self.myGCppPath
		self.myLinkFlags	= ''
		self.myLibPath		= self.myGLibPath


	###### Read a *.options file ######
	def readOptions( self, file ) :
		myOptions	= Options( file )
		myOptions.AddOptions(
			('localWin32',		'Set the list of search paths to local directories for win32 platform. The first one would be used as a destination path for target named install'),
			('localCygwin',	'Set the list of search paths to local directories for cygwin platform. The first one would be used as a destination path for target named install'),	
			('localLinux',		'Set the list of search paths to local directories for linux platform. The first one would be used as a destination path for target named install'),
			('localDarwin',	'Set the list of search paths to local directories for darwin platform. The first one would be used as a destination path for target named install'),
			('local',			'Set the list of search paths to local directories for all others platforms. The first one would be used as a destination path for target named install'),

			('buildPath',		'Set the path to the directory in which to build all files (path could be absolute or relative to the project beiing build)', 'build' ),

			EnumOption(	'config', 'Select a release or debug binary.', 'release',
							allowed_values=('debug', 'release'),
							map={}, ignorecase=2 ),
			EnumOption( 'warningLevel', 'Select level of warnings.', 'normal',
							allowed_values=('normal', 'high'),
							map={}, ignorecase=2 ),

			( 'defines', 'Set the list of predefined names (as a macro)'),
			EnumOption( 'type', 'Type of the target', 'exec',
							allowed_values=('exec', 'static','shared'),
							map={}, ignorecase=2 ),
			('postfix', 'Add a postfix to the target name'),

			('deps', 'Set dependencies to others projects (all dependencies are automatically built)'),

			('uses', 'Set usage of some predefined libraries (boost, opengl, openil, glu, glut, wx2-4, wxgl2-4)'),
			# (cg|cgFX|imageMagick6|imageMagick++6|itk)')
			#ListOption(	'uses', 'Set usage of some predefined libraries', 'none',
			#				['boost','opengl','openil','glu','glut','wx2-4','wxgl2-4'] ), # (cg|cgFX|imageMagick6|imageMagick++6|itk)')

			('libs', 'Set libraries used during the link stage that have been compiled with SConsBuildFramework (this scons system)'),
			('stdlibs', 'Set the standard libraries used during the link stage.')
								)
		return myOptions


	###### configure CxxFlags & LinkFlags ######
	def configureCxxFlagsAndLinkFlagsOnWin32( self, lenv ) :
	
		self.myCxxFlags += ' /nologo /GR /GX -DWIN32 -D_MBCS'
		if ( self.myConfig == 'release' ) :																### TODO: use /Zd in release mode to be able to debug a little.
			self.myCxxFlags += ' -DNDEBUG /W3 /Zm600 /MD /O2 /TP '								### { /Gi ignored } and { /Og /Oi /Ot /Ob2 (in O2) }
		else :
			self.myCxxFlags += ' -D_DEBUG -DDEBUG /EHsc /MDd /Od'
			if '7' in lenv['MSVS']['VERSION'] :
				self.myCxxFlags += ' /Z7 '
			else :
				self.myCxxFlags += ' /Zi '
		if ( self.myWarningLevel == 'normal' ) :														### TODO: it is dependant of the myConfig. Must be changed ? yes, done...
			self.myCxxFlags += ' /W3 '
		else :
			self.myCxxFlags += ' /W4 '
			if '7' in lenv['MSVS']['VERSION'] :
				self.myCxxFlags += ' /Wp64 '
																													##/machine:I386
		self.myLinkFlags	+= ' /nologo /subsystem:windows /incremental:yes '					##/subsystem:console
		self.myCxxFlags	+= ' -D_WINDOWS '
																													## remove CONSOLE, MFC support, NOLIB
		# process myType
		if ( self.myType == 'exec' ) :
			self.myCxxFlags += ' /GA '
		else :
			if ( self.myType == 'shared' ) :
				self.myCxxFlags	+= ' -D_USRDLL '
				if '7' in lenv['MSVS']['VERSION'] :
					self.myCxxFlags += ' /G7 '
				else :
					self.myCxxFlags += ' /GD '																## remove Boundchecker support.


	def configureCxxFlagsAndLinkFlagsOnPosix( self, lenv ) :
	
		lenv['CXX'] = lenv.WhereIs('g++')															### myCxxFlags += ' -pedantic'
		if ( self.myConfig == 'release' ) :
			self.myCxxFlags	+= ' -DNDEBUG -O3 '													### TODO: more compiler arch-dependant optimization
		else :
			self.myCxxFlags	+= ' -D_DEBUG -DDEBUG -UNDEBUG -g -O0 '						### profiling myCxxFlags += ' -pg', mpatrol, leaktracer

		# process myWarningLevel, add always -Wall option.										### TODO: add more warnings with myWarningLevel = 'high' ?
		self.myCxxFlags	+= ' -Wall '


	def configureCxxFlagsAndLinkFlags( self, lenv ) :

		### complete myCxxFlags and myLinkFlags ###
		if ( self.myPlatform == 'win32' ) :
			self.configureCxxFlagsAndLinkFlagsOnWin32( lenv )
		elif ( self.myPlatform == 'cygwin' or self.myPlatform == 'posix' ) :
			self.configureCxxFlagsAndLinkFlagsOnPosix( lenv )
		else:
			print 'myWarning: unknown platform (', self.myPlatform, ')'

		# complete myCxxFlags with some defines
		if ( self.myType != 'exec' ) :
			self.myCxxFlags += ' -D' + self.myProject.upper() + '_EXPORTS '

		if ( sys.platform == 'darwin' ) :
			self.myCxxFlags += ' -D__MACOSX__'
		elif ( string.find( sys.platform, 'linux' ) != -1 ) :
			self.myCxxFlags += ' -D__linux'


	###### use_package (see option named 'uses') ######
	def use_boost( self, lenv, elt ) :
		if		( self.myPlatform != 'win32' ) :
			lenv['LIBS']	+= [	'boost_date_time-gcc-mt', 'boost_filesystem-gcc-mt', 'boost_regex-gcc-mt', 'boost_signals-gcc-mt', 'boost_thread-gcc-mt' ]
			#						[	'boost_date_time-gcc-mt', 'boost_filesystem-gcc-mt', 'boost_prg_exec_monitor-gcc-mt', 'boost_regex-gcc-mt',
			#							'boost_signals-gcc-mt', 'boost_test_exec_monitor-gcc-mt', 'boost_thread-gcc-mt', 'boost_unit_test_framework-gcc-mt' ]
		#else:
		# Nothing to do for win32 platform.

	def use_openIL( self, lenv, elt ) :
		if		( self.myPlatform == 'win32' ) :
			if ( self.myConfig == 'release' ) :
				lenv['LIBS']	+= ['DevIL']
			else :
				lenv['LIBS']	+= ['DevILd']
		else :
			if ( self.myConfig == 'release' ) :
				lenv['LIBS']	+= ['IL']
			else :
				lenv['LIBS']	+= ['ILd']

	def use_wxWidgets( self, lenv, elt ) :
		if		( self.myPlatform == 'win32' ) :
			lenv['CXXFLAGS'] += ' -DWXUSINGDLL -D__WIN95__ '
			if ( (elt == 'wx2-4') or (elt == 'wxgl2-4') ) :
				if ( self.myConfig == 'release' ) :
						lenv['LIBS'] +=	['wxmsw24']
				else:
						lenv['LIBS'] +=	['wxmsw24d']
			else :
				print "myWarning: Unsupported version of wxWidgets"
		else :
			if ( re.match('^wx[\d-]*$', elt) ) :
				lenv.ParseConfig('wx-config --cppflags --ldflags --libs')
			else:
				lenv.ParseConfig('wx-config --cppflags --ldflags --libs --gl-libs')

	def uses( self, lenv ) :
	
		for elt in lenv['uses'] :
			elt = string.lower( elt )
			
			### configure boost ###
			if ( elt == 'boost' ) :
				self.use_boost( lenv, elt )
	
			### configure OpenGL ###
			elif ( elt == 'opengl' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['opengl32']
				else :
					lenv['LIBS'] += ['GL']
	
			### configure openIL ###
			elif ( elt == 'openil' ) :
				self.use_openIL( lenv, elt )
	
			### configure glu ###
			elif ( elt == 'glu' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['glu32']
				else :
					lenv['LIBS'] += ['GLU']
	
			### configure glut ###
			elif ( elt == 'glut' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['glut32']
				else :
					lenv['LIBS'] += ['glut']
	
			### configure wx* ###
			elif ( re.match('^wx[\d-]*$', elt ) or re.match('^wxgl[\d-]*$', elt ) ) :
				self.use_wxWidgets( lenv, elt )

			else :
				print "myWarning: unknown uses=[", elt, "']"


	###### Build a project ######
	def buildProject( self, projectPathName ) :

		# configure a new environment
		lenv = env.Copy()

		# update lenv with build.options
		myBuildOptions = self.readOptions( projectPathName + os.sep + 'default.options' )
		myBuildOptions.Update( lenv )

		# construct dependencies
		for dep in lenv['deps'] :
			if ( dep not in self.myParsedProjects ) :
				# dep not already "build"
				self.myParsedProjects += [dep]
				if ( len(os.path.split(dep)[0]) == 0 ) :
					self.buildProject( os.path.abspath(os.path.join('../', dep)) )
				else :
					self.buildProject( os.path.abspath(dep) )
			#else nothing to do, project already "build"

		# initialize the project.
		self.initializeProjectFromEnv( lenv )
		self.initializeProject( projectPathName )

		# force clean=1 option if needed.
		if (	('clean' in self.myBuildTargets)							or
				('mrproper' in self.myBuildTargets)						or
				(self.myProject + '_clean' in self.myBuildTargets)	or
				(self.myProject + '_mrproper' in self.myBuildTargets ) ) :
			lenv.SetOption('clean', 1)

		# used by code printing messages during the different build stage.
		lenv['MY_PROJECT'] = projectPathName

		os.chdir( projectPathName )

		# Dumping construction environment (for debugging).																			# TODO : a method printDebugInfo()
		#DumpEnv.DumpEnv( lenv )
		#print 'DEBUG:cwd=', os.getcwd()

		### construct project ###

		### expand myProjectBuildPathExpanded
		self.myProjectBuildPathExpanded = self.myProjectBuildPath + os.sep + self.myProject + os.sep + self.myPlatform + os.sep + self.myCC + os.sep + self.myConfig

		if ( len(self.myPostfix) > 0 ) :
			self.myProjectBuildPathExpanded += '_' + self.myPostfix

		### configure myCxxFlags with myDefines
		for define in self.myDefines :
			self.myCxxFlags	+=	' -D' + define + ' '

		###
		self.configureCxxFlagsAndLinkFlags( lenv )

		###### configure environment ######
		lenv['CXXFLAGS']	= self.myCxxFlags
		lenv['CPPPATH']	= self.myCppPath
		lenv['LINKFLAGS']	= self.myLinkFlags
		lenv['LIBPATH']	= self.myLibPath

		# configure lenv['LIBS'] with lenv['stdlibs']
		lenv['LIBS'] = lenv['stdlibs']

		# configure lenv['LIBS'] with lenv['libs']
		for lib in lenv['libs'] :
			libSplited	= string.split(lib, ' ')
			libExpanded = ''
			if ( len(libSplited) == 1 ) :
				libExpanded += lib + self.myPlatform_myCC + self.myPostfixLinkedToMyConfig
			elif ( len(libSplited) == 2 ) :
				libExpanded += libSplited[0] + self.myPlatform_myCC + '_' + libSplited[1] + self.myPostfixLinkedToMyConfig
			else:
				print 'myWarning: skip ', lib, ' because its name contains more than two spaces'

			lenv['LIBS'] += [libExpanded]

		# configure lenv[*] with lenv['uses']
		self.uses( lenv )

		###### setup 'pseudo BuildDir' (with OBJPREFIX) ######
		###										TODO: .cpp .cxx .c => config.options global, idem for pruneDirectories, .h .... => config.options global ?
		filesFromSrc		= []
		filesFromInclude	= []

		searchFiles( 'src', ['.*', 'DEBUG_*', 'RELEASE_*'], ['.cpp'], filesFromSrc )
		searchFiles( 'include', ['.*'], ['.hpp','.hxx','.h'], filesFromInclude )

		objFiles = []

		if		( self.myType == 'exec' or self.myType == 'static' ) :
			for srcFile in filesFromSrc :
				objFile				=	(os.path.splitext(srcFile)[0]).replace('src', self.myProjectBuildPathExpanded )
				srcFileExpanded	=	self.myProjectPathName + os.sep + srcFile
				objFiles	+=	lenv.Object( objFile, srcFileExpanded )				# Object is a synonym for the StaticObject builder method.
				### print objFile, ':', srcFileExpanded, '\n'

		elif	( self.myType == 'shared' ) :
			for srcFile in filesFromSrc :
				objFile				=	(os.path.splitext(srcFile)[0]).replace('src', self.myProjectBuildPathExpanded )
				srcFileExpanded	=	self.myProjectPathName + os.sep + srcFile
				objFiles	+=	lenv.SharedObject( objFile, srcFileExpanded )
				### print objFile, ':', srcFileExpanded, '\n'
		else :
			print 'myWarning: during setup of pseudo BuildDir'


		### final result of project ###
		objProject = self.myProjectBuildPathExpanded + os.sep + self.myProject + self.myPlatform_myCC
		# or objProject = self.myProjectBuildPath + os.sep + self.myProject + os.sep + self.myProject + self.myPlatform_myCC		

		if ( len(self.myPostfix) > 0 ) :
			objProject += '_' + self.myPostfix

		objProject += self.myPostfixLinkedToMyConfig

		if		( self.myType == 'exec' ) :
			projectTarget = lenv.Program(			objProject, objFiles )
		elif	( self.myType == 'static' ) :
			projectTarget = lenv.StaticLibrary(	objProject, objFiles )
		elif	( self.myType == 'shared' ) :
			projectTarget = lenv.SharedLibrary(	objProject, objFiles )
		else :
			print 'myWarning: during final setup of project'
		#																																			TODO: myType == 'headers'

		######	setup targets : myProject_build myProject_install myProject myProject_clean myProject_mrproper ######

		### myProject_build
		env.Alias( self.myProject + '_build_print', lenv.Command('dummy_build_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
		env.Alias( self.myProject + '_build_print', lenv.Command('dummy_build_print' + self.myProject + 'out2', 'dummy.in', Action( nopAction, printBuild ) ) )
		env.AlwaysBuild( self.myProject + '_build_print' )

		aliasProjectBuild = env.Alias( self.myProject + '_build', self.myProject + '_build_print' )
		env.Alias( self.myProject + '_build', projectTarget )
		env.Clean( self.myProject + '_build', self.myProjectBuildPathExpanded  )

		### myProject_install
		if		( self.myType == 'exec' ) :
			installTarget =	lenv.Install( self.myInstallDirectory + os.sep + 'bin', projectTarget )
		elif	( self.myType == 'static' or self.myType == 'shared') :
			installTarget =	lenv.Install( self.myInstallDirectory + os.sep + 'lib', projectTarget )
		else :
			print 'myWarning: unexpected value during install setup for type=', self.myType

		for file in filesFromInclude :
			installTarget +=	lenv.InstallAs( self.myInstallDirectory + os.sep + file, self.myProjectPathName + os.sep + file )

		env.Alias( self.myProject + '_install_print', lenv.Command('dummy_install_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printInstall ) ) )
		env.AlwaysBuild( self.myProject + '_install_print' )

		aliasProjectInstall = env.Alias( self.myProject + '_install', self.myProject + '_build' )
		env.Alias( self.myProject + '_install', self.myProject + '_install_print' )
		env.Alias( self.myProject + '_install', installTarget )

		### myProject
		aliasProject = env.Alias( self.myProject, aliasProjectInstall )

		### myProject_clean

		### FIXME																									printClean does'nt work ??? modified behavior when clean=1 ?
		#env.Alias( self.myProject + '_clean_print', lenv.Command('dummy_clean_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
		#env.Alias( self.myProject + '_clean_print', lenv.Command('dummy_clean_print' + self.myProject + 'out2', 'dummy.in', Action( nopAction, printClean ) ) )
		#env.AlwaysBuild( self.myProject + '_clean_print' )
		#env.Alias( self.myProject + '_clean', self.myProject + '_clean_print' )

		aliasProjectClean = env.Alias( self.myProject + '_clean', self.myProject + '_build' )

		### myProject_mrproper
		# FIXME: TODO: printMrproper see myProject_clean target.

		aliasProjectMrproper = env.Alias( self.myProject + '_mrproper', aliasProjectInstall )
		env.Clean( self.myProject + '_mrproper', self.myProjectBuildPath + os.sep + self.myProject )
		env.Clean( self.myProject + '_mrproper', self.myInstallDirectory + os.sep + 'include' + os.sep + self.myProject )

		###### special targets: build install all clean mrproper ######
		env.Alias( 'build', aliasProjectBuild )
		env.Alias( 'install', aliasProjectInstall )
		env.Alias( 'all', aliasProject )
		env.Alias( 'clean', aliasProjectClean )
		env.Alias( 'mrproper', aliasProjectMrproper )



###### Initial environment ######

# create objects
# HINTS: to propagate the entire external environment to the execution environment for commands : ENV = os.environ
env							=	Environment()
env['ENV']['PATH']		+=	os.environ['PATH']

#Export('env') not needed.
SConsEnvironment.sbf		= SConsBuildFramework()

# target 'checkVersion'
Alias('checkVersion')
env.Alias('checkVersion', env.Command('dummyCheckVersion.out1', 'dummy.in', Action( printCheckMessage, nopAction ) ) )
env.Alias('checkVersion', env.Command('dummyCheckVersion.out2', 'dummy.in', Action( 'python -V' ) ) )
env.Alias('checkVersion', env.Command('dummyCheckVersion.out3', 'dummy.in', Action( printEmptyLine, nopAction ) ) )
env.Alias('checkVersion', env.Command('dummyCheckVersion.out4', 'dummy.in', Action( 'scons -v' ) ) )
env.Alias('checkVersion', env.Command('dummyCheckVersion.out5', 'dummy.in', Action( printEmptyLine, nopAction ) ) )
env.Alias('checkVersion', env.Command('dummyCheckVersion.out6', 'dummy.in', Action( checkCC, nopAction ) ) )

# build 'caller' project (and all dependancies recursively)
env.sbf.buildProject( os.getcwd() )

env.Default( 'all' )
