# SConsBuildFramework - Copyright (C) 2005, Nicolas Papier.
# Distributed under the terms of the GNU General Public License (GPL)
# as published by the Free Software Foundation.
# Author Nicolas Papier

# Installation : 
# --------------
#
# Python 2.3 and up
# SCons 0.96.1 and up
#
# SCONS_BUILD_FRAMEWORK environment variable must be set to the SConsBuildFramework root directory. It must be terminated by a '\' on windows platform and a '/' in all others one (for example: SCONS_BUILD_FRAMEWORK=D:\SConsBuildFramework\)
#
# The configuration of SBF is done by the file .SConsBuildFramework.options from $HOME directory. If this file is not present then configuration is done with SConsBuildFramework.options from $SCONS_BUILD_FRAMEWORK directory.
#
# Features :
# ----------
#
# - targets sbfCheck,
#   and myproject_build, myproject_install, myproject(idem myproject_install), myproject_clean, myproject_mrproper
#   and special targets build (for all myproject_build), install (for all myproject_install), all (for all myproject), clean (for all myproject_clean), mrproper (for all myproject_mrproper)
# - default target = all
# - projects dependencies (deps could be specified with name of project (search in parent directory), absolute path or relative path).
# - skip any missing projects (i.e. skip a project specified in dependencies but that don't exist on the filesystem).
#
# - build objects outside sources directories.
# - builded files could be shared among all the builds usings the same cache (see cachePath).
# - ...
#
# Rqs :
# -----
#
# - spaces in target name are prohibited.
# - installPaths, config and warningLevel are not used in default.options (only in SConsBuildFramework.options)
# ...
#
# Developper comments:
# - SBF_PROJECT for internal use only.



###### ######
import fnmatch
import os
import re
import string
import sys

from SCons.Script.SConscript import SConsEnvironment
#import DumpEnv



###### Searching files in a filesystem ######
# Prune some directories
# Exclude/retain only a specific set of extensions for files
def searchFiles( searchDirectory, pruneDirectories, allowedExtensions, oFiles ) :
	for dirpath, dirnames, filenames in os.walk( searchDirectory, topdown=True ):
		# prune directories
		prune = []
		for pruneDirectory in pruneDirectories :
			prune.extend( fnmatch.filter(dirnames, pruneDirectory) )
		for x in prune:
			###print 'prune', x
			dirnames.remove( x )

		for file in filenames:
			for extension in allowedExtensions :
				if ( os.path.splitext(file)[1] == extension ) :
					pathfilename = os.path.join(dirpath,file)
					oFiles += [pathfilename]
					break

	###print 'oFiles=', oFiles



###### Action function for sbfCheck target #######
def printCheckMessage(target = None, source = None, env = None) :
	print '----------------------- Check version -----------------------'

def checkCC(target = None, source = None, env = None) :
	if ( env['CC'] == 'cl' ) :
		#ccVersionAction		= Action( 'cl /help' )
		print env['CC'], ' --version '
		print 'cl ', env['MSVS']['VERSION']
	else :
		ccVersionAction		= Action( env['CC'] + ' -v' )
		env.Execute( ccVersionAction )

def checkSBF(target = None, source = None, env = None) :

	print 'SConsBuildFramework 0.2'

	sbf_home = os.getenv('SCONS_BUILD_FRAMEWORK')
	print 'Environment variable SCONS_BUILD_FRAMEWORK=', sbf_home

	if ( len( sbf_home ) > 0 ) :
		if ( sbf_home[ len(sbf_home)-1 ] != os.sep ) :
			print 'sbfError: SCONS_BUILD_FRAMEWORK must be terminated by a directory separator !!!'
		else:
			print 'sbfInfo: SCONS_BUILD_FRAMEWORK is well formed.'
	else :
		print 'sbfError: SCONS_BUILD_FRAMEWORK must be defined or non empty !!!'


###### Print action function ######
def nopAction(target = None, source = None, env = None) :
	return 0

def printEmptyLine(target = None, source = None, env = None) :
	print ''

def printBuild( target, source, localenv ) :
	return "----------------------- Build %s -----------------------" % localenv['SBF_PROJECT']

def printInstall( target, source, localenv ) :
	return "-------------- Install %s files to %s ------------" % (localenv['SBF_PROJECT'], localenv.sbf.myInstallDirectory)

def printClean( target, source, localenv ) :
	return "-------------- Clean %s files to %s ------------" % (localenv['SBF_PROJECT'], localenv.sbf.myInstallDirectory)

def printMrproper( target, source, localenv ) :
	return "-------------- Mrproper %s files to %s ------------" % (localenv['SBF_PROJECT'], localenv.sbf.myInstallDirectory)


###### SConsBuildFramework class ######

class SConsBuildFramework :

	# global attributes from command line
	myBuildTargets						= []
	#myGHasCleanOption				= False

	# globals attributes
	myPlatform							= ''
	myCC									= ''
	myPlatform_myCC					= ''

	# global attributes from sbf.options or computed ftom sbf.options
	# from sbf.options
	myInstallPaths						= []
	myBuildPath							= ''
	myCachePath							= ''
	myConfig								= ''
	myWarningLevel						= ''
	# computed from sbf.options
	myInstallExtPaths					= []
	myInstallDirectory				= ''
	myGlobalCppPath					= []
	myGlobalLibPath					= []

	# project local attributes from default.options
	myDefines							= []
	myType								= ''
	myPostfix							= ''
	myDeps								= []
	myUses								= []
	myLibs								= []
	myStdlibs							= []

	# project local attributes
	myProjectPathName					= ''
	myProjectPath						= ''
	myProject							= ''
	myProjectBuildPath				= ''
	myPostfixLinkedToMyConfig		= ''

	myCxxFlags							= ''
	myCppPath							= []
	myLinkFlags							= ''
	myLibPath							= []

	myProjectBuildPathExpanded		= ''

	# list of projects that have been already parsed by scons
	myParsedProjects					= []


	###### Constructor ######
	def __init__(self) :

		# read .SConsBuildFramework.options from HOME or SConsBuildFramework.options from SCONS_BUILD_FRAMEWORK.
		homeSConsBuildFrameworkOptions = os.path.expanduser('~/.SConsBuildFramework.options')

		if ( os.path.isfile(homeSConsBuildFrameworkOptions) ) :
			myOptions = self.readOptions( homeSConsBuildFrameworkOptions )
		else :
			myOptions = self.readOptions( os.path.join( os.getenv('SCONS_BUILD_FRAMEWORK'), 'SConsBuildFramework.options' ) )

		# update env and generate help
		myOptions.Update( env )
		Help( myOptions.GenerateHelpText(env) )

		# retrives all targets
		self.myBuildTargets = map(str, BUILD_TARGETS)

		#self.myGHasCleanOption = env.GetOption('clean')

		# force clean=1 option if needed.
		if (	('clean' in self.myBuildTargets) or
				('mrproper' in self.myBuildTargets) ) :
			if ( len(self.myBuildTargets) != 1 ) :
				print 'sbfError: only one target allowed when using special target clean or mrproper'
				Exit( 1 )
			else :
				env.SetOption('clean', 1)

		# myPlatform, myCC and myPlatform_myCC
		# myPlatform = win32 | cygwin  | posix | darwin					FIXME: posix != linux or cygwin or bsd ?, env['PLATFORM'] != sys.platform => TOTHINK
		self.myPlatform			= env['PLATFORM']

		# myCC = clX-Y | gcc | env['CC']
		if		( env['CC'] == 'cl' ) :
			self.myCC = 'cl' + env['MSVS_VERSION'].replace('.','-')
		elif	( env['CC'] == 'g++') :
			self.myCC = 'gcc'
		else :
			self.myCC = env['CC']

		self.myPlatform_myCC = '_' + self.myPlatform + '_' + self.myCC

		#
		self.initializeGlobalsFromEnv( env )


	###### Initialize global attributes ######
	def initializeGlobalsFromEnv( self, lenv ) :

		# update myInstallPaths, myIntallExtPaths and myInstallDirectory
		self.myInstallPaths = lenv['installPaths']

		self.myInstallExtPaths = []
		for element in self.myInstallPaths :
			self.myInstallExtPaths	+= [element + 'Ext' + self.myPlatform_myCC ]

		if ( len(self.myInstallPaths) >= 1 ) :
			self.myInstallDirectory	= self.myInstallPaths[0]
		else :
			print 'sbfError: empty installPaths'
			sys.exit()

		# update myBuildPath, myCachePath, myConfig and myWarning
		self.myBuildPath			= lenv['buildPath']
		
		self.myCachePath			= lenv['cachePath']
		if ( len( self.myCachePath ) > 0 ) :
			env.CacheDir( self.myCachePath )
			print 'sbfInfo: Use cache ', self.myCachePath
		else :
			print 'sbfInfo: Don\'t use cache'
		
		self.myConfig				= lenv['config']
		self.myWarningLevel		= lenv['warningLevel']

		### use myInstallPaths to update myGlobalCppPath ###
		self.myGlobalCppPath = []
		for element in self.myInstallPaths :
			self.myGlobalCppPath	+= [element + os.sep + 'include']
			self.myGlobalCppPath	+= [element + 'Ext' + self.myPlatform_myCC + os.sep + 'include']

		### use myInstallPaths to update myGlobalLibPath ###
		self.myGlobalLibPath = []
		for element in self.myInstallPaths :
			self.myGlobalLibPath	+=	[element + os.sep + 'lib']
			self.myGlobalLibPath	+=	[element + 'Ext' + self.myPlatform_myCC + os.sep + 'lib']


	###### Initialize project from lenv ######
	def initializeProjectFromEnv( self, lenv ) :
		self.myDefines			= lenv['defines']
		self.myType				= lenv['type']
		self.myPostfix			= lenv['postfix']
		self.myDeps				= lenv['deps']
		self.myUses				= lenv['uses']
		self.myLibs				= lenv['libs']
		self.myStdlibs			= lenv['stdlibs']


	###### Initialize project ######
	def initializeProject( self, projectPathName ) :

		self.myProjectPathName	= projectPathName
		self.myProjectPath		= os.path.dirname( projectPathName )
		self.myProject				= os.path.basename(projectPathName)
		if ( os.path.isabs(self.myBuildPath) ) :
			self.myProjectBuildPath = os.path.abspath( self.myBuildPath )
		else :
			self.myProjectBuildPath = os.path.join( self.myProjectPathName, self.myBuildPath )

		if ( self.myConfig == 'debug' ) :										### TODO: not good if more than one config could be built
			self.myPostfixLinkedToMyConfig = '_D'
		else : 
			self.myPostfixLinkedToMyConfig = ''

		###
		self.myCxxFlags	= ''
		self.myCppPath		= [self.myProjectPathName + os.sep + 'include'] + self.myGlobalCppPath
		self.myLinkFlags	= ''
		self.myLibPath		= self.myGlobalLibPath


	###### Read a *.options file ######
	def readOptions( self, file ) :
		myOptions	= Options( file )
		myOptions.AddOptions(
			('installPaths', 'Set the list of search paths to \'/usr/local\' like directories. The first one would be used as a destination path for target named install'),

			('buildPath',	'Set the path to the directory in which to build all files (path could be absolute or relative to the project beiing build)', 'build' ),
			('cachePath',	'Set the path to cache that will be shared among all the builds using the same cachePath', ''),

			EnumOption(	'config', 'Select a release or debug binary.', 'release',
							allowed_values=('debug', 'release'),
							map={}, ignorecase=2 ),
			EnumOption( 'warningLevel', 'Select level of warnings.', 'normal',
							allowed_values=('normal', 'high'),
							map={}, ignorecase=2 ),

			( 'defines', 'Set the list of predefined names (as a macro)'),
			EnumOption( 'type', 'Type of the target', 'exec',
							allowed_values=('exec', 'static','shared'),
							map={}, ignorecase=2 ),
			('postfix', 'Add a postfix to the target name'),

			('deps', 'Set dependencies to others projects (all dependencies are automatically built)'),

			('uses', 'Set usage of some predefined libraries (boost, opengl, openil, glu, glut, wx2-4, wxgl2-4)'),
			# (cg|cgFX|imageMagick6|imageMagick++6|itk)')
			#ListOption(	'uses', 'Set usage of some predefined libraries', 'none',
			#				['boost','opengl','openil','glu','glut','wx2-4','wxgl2-4'] ), # (cg|cgFX|imageMagick6|imageMagick++6|itk)')

			('libs', 'Set libraries used during the link stage that have been compiled with SConsBuildFramework (this scons system)'),
			('stdlibs', 'Set the standard libraries used during the link stage.')
								)
		return myOptions


	###### configure CxxFlags & LinkFlags ######
	def configureCxxFlagsAndLinkFlagsOnWin32( self, lenv ) :
	
		self.myCxxFlags += ' /nologo /GR /GX -DWIN32 -D_MBCS'
		if ( self.myConfig == 'release' ) :																### TODO: use /Zd in release mode to be able to debug a little.
			self.myCxxFlags += ' -DNDEBUG /W3 /Zm600 /MD /O2 /TP '								### { /Gi ignored } and { /Og /Oi /Ot /Ob2 (in O2) }
		else :
			self.myCxxFlags += ' -D_DEBUG -DDEBUG /EHsc /MDd /Od'
			if '7' in lenv['MSVS']['VERSION'] :
				self.myCxxFlags += ' /Z7 '
			else :
				self.myCxxFlags += ' /Zi '
		if ( self.myWarningLevel == 'normal' ) :														### TODO: it is dependant of the myConfig. Must be changed ? yes, done...
			self.myCxxFlags += ' /W3 '
		else :
			self.myCxxFlags += ' /W4 '
			if '7' in lenv['MSVS']['VERSION'] :
				self.myCxxFlags += ' /Wp64 '
																													##/machine:I386
		self.myLinkFlags	+= ' /nologo /subsystem:windows /incremental:yes '					##/subsystem:console
		self.myCxxFlags	+= ' -D_WINDOWS '
																													## remove CONSOLE, MFC support, NOLIB
		# process myType
		if ( self.myType == 'exec' ) :
			self.myCxxFlags += ' /GA '
		else :
			if ( self.myType == 'shared' ) :
				self.myCxxFlags	+= ' -D_USRDLL '
				if '7' in lenv['MSVS']['VERSION'] :
					self.myCxxFlags += ' /G7 '
				else :
					self.myCxxFlags += ' /GD '																## remove Boundchecker support.


	def configureCxxFlagsAndLinkFlagsOnPosix( self, lenv ) :
	
		lenv['CXX'] = lenv.WhereIs('g++')															### myCxxFlags += ' -pedantic'
		if ( self.myConfig == 'release' ) :
			self.myCxxFlags	+= ' -DNDEBUG -O3 '													### TODO: more compiler arch-dependant optimization
		else :
			self.myCxxFlags	+= ' -D_DEBUG -DDEBUG -g -O0 '									### profiling myCxxFlags += ' -pg', mpatrol, leaktracer

		# process myWarningLevel, add always -Wall option.										### TODO: add more warnings with myWarningLevel = 'high' ?
		self.myCxxFlags	+= ' -Wall '


	def configureCxxFlagsAndLinkFlags( self, lenv ) :

		### complete myCxxFlags and myLinkFlags ###
		if ( self.myPlatform == 'win32' ) :
			self.configureCxxFlagsAndLinkFlagsOnWin32( lenv )
		elif ( self.myPlatform == 'cygwin' or self.myPlatform == 'posix' ) :
			self.configureCxxFlagsAndLinkFlagsOnPosix( lenv )
		else:
			print 'sbfWarning: unknown platform (', self.myPlatform, ')'

		# complete myCxxFlags with some defines
		if ( self.myType == 'shared' ) :
			self.myCxxFlags += ' -D' + self.myProject.upper() + '_EXPORTS '

		if ( sys.platform == 'darwin' ) :
			self.myCxxFlags += ' -D__MACOSX__'
		elif ( string.find( sys.platform, 'linux' ) != -1 ) :
			self.myCxxFlags += ' -D__linux'


	###### use_package (see option named 'uses') ######
	def use_boost( self, lenv, elt ) :
		if ( self.myPlatform != 'win32' ) :
			lenv['LIBS']	+= [	'boost_date_time-gcc-mt', 'boost_filesystem-gcc-mt', 'boost_regex-gcc-mt', 'boost_signals-gcc-mt', 'boost_thread-gcc-mt' ]
			#						[	'boost_date_time-gcc-mt', 'boost_filesystem-gcc-mt', 'boost_prg_exec_monitor-gcc-mt', 'boost_regex-gcc-mt',
			#							'boost_signals-gcc-mt', 'boost_test_exec_monitor-gcc-mt', 'boost_thread-gcc-mt', 'boost_unit_test_framework-gcc-mt' ]
		#else:
		# Nothing to do for win32 platform.

	def use_openIL( self, lenv, elt ) :
		if ( self.myPlatform == 'win32' ) :
			lenv['LIBS']	+= ['DevIL']
#			if ( self.myConfig == 'release' ) :																								### FIXME
#			else :
#				lenv['LIBS']	+= ['DevILd']
		else :
			lenv['LIBS']	+= ['IL']
#			if ( self.myConfig == 'release' ) :
#			else :
#				lenv['LIBS']	+= ['ILd']

	def use_wxWidgets( self, lenv, elt ) :
		if	( self.myPlatform == 'win32' ) :
			lenv['CXXFLAGS'] += ' -DWXUSINGDLL -D__WIN95__ '
			if ( (elt == 'wx2-4') or (elt == 'wxgl2-4') ) :
				if ( self.myConfig == 'release' ) :
						lenv['LIBS'] +=	['wxmsw24']
				else:
						lenv['LIBS'] +=	['wxmsw24d']
			else :
				print "sbfWarning: Unsupported version of wxWidgets"
		else :
			lenv['CXXFLAGS'] += ' -DGTK_NO_CHECK_CASTS -D__WXGTK__ -D_FILE_OFFSET_BITS=64 -D_LARGE_FILES '					### FIXME: bug in ParseConfig() ?
			if re.match('^wx[\d-]*$', elt ):
				env.ParseConfig('wx-config --prefix=' + os.path.join( self.myInstallExtPaths[0], 'lib' ) + ' --cppflags --ldflags --libs')
			else:
				env.ParseConfig('wx-config --prefix=' + os.path.join( self.myInstallExtPaths[0], 'lib' ) + ' --cppflags --ldflags --libs --gl-libs')

	def uses( self, lenv ) :
	
		for elt in lenv['uses'] :
			elt = string.lower( elt )
			
			### configure boost ###
			if ( elt == 'boost' ) :
				self.use_boost( lenv, elt )
	
			### configure OpenGL ###
			elif ( elt == 'opengl' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['opengl32']
				else :
					lenv['LIBS'] += ['GL']
	
			### configure openIL ###
			elif ( elt == 'openil' ) :
				self.use_openIL( lenv, elt )
	
			### configure glu ###
			elif ( elt == 'glu' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['glu32']
				else :
					lenv['LIBS'] += ['GLU']
	
			### configure glut ###
			elif ( elt == 'glut' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['glut32']
				else :
					lenv['LIBS'] += ['glut']

			### configure wx* ###
			elif ( re.match('^wx[\d-]*$', elt ) or re.match('^wxgl[\d-]*$', elt ) ) :
				self.use_wxWidgets( lenv, elt )

			### configure others ? ###
			else :
				print "sbfWarning: unknown uses=[", elt, "']"


	###### Build a project ######
	def buildProject( self, projectPathName ) :

		# check if projectPathName is valid
		if ( os.path.isdir(projectPathName) == False ) :
			print "sbfWarning: Unable to find directory", projectPathName + '.', "Ignore project", os.path.basename( projectPathName ) + '.'
			# FIXME todo try a svn checkout ?
			return

		# configure a new environment
		lenv = env.Copy()

		# update lenv with build.options
		myBuildOptions = self.readOptions( projectPathName + os.sep + 'default.options' )
		myBuildOptions.Update( lenv )

		# construct dependencies
		for dep in lenv['deps'] :
			if ( dep not in self.myParsedProjects ) :
				# dep not already "build"
				self.myParsedProjects += [dep]
				if ( len(os.path.split(dep)[0]) == 0 ) :
					self.buildProject( os.path.abspath(os.path.join('../', dep)) )
				else :
					self.buildProject( os.path.abspath(dep) )
			#else nothing to do, project already "build"

		# initialize the project.
		self.initializeProjectFromEnv( lenv )
		self.initializeProject( projectPathName )

		# force clean=1 option if needed.
		if (	('clean' in self.myBuildTargets)							or
				('mrproper' in self.myBuildTargets)						or
				(self.myProject + '_clean' in self.myBuildTargets)	or
				(self.myProject + '_mrproper' in self.myBuildTargets ) ) :
			lenv.SetOption('clean', 1)

		# used by code printing messages during the different build stage.
		lenv['SBF_PROJECT'] = projectPathName

		os.chdir( projectPathName )																											# FIXME is chdir done at scons level ?

		# Dumping construction environment (for debugging).																			# TODO : a method printDebugInfo()
		#DumpEnv.DumpEnv( lenv )
		#print 'DEBUG:cwd=', os.getcwd()

		### construct project ###

		### expand myProjectBuildPathExpanded
		self.myProjectBuildPathExpanded = self.myProjectBuildPath + os.sep + self.myProject + os.sep + self.myPlatform + os.sep + self.myCC + os.sep + self.myConfig

		if ( len(self.myPostfix) > 0 ) :
			self.myProjectBuildPathExpanded += '_' + self.myPostfix

		### configure myCxxFlags with myDefines
		for define in self.myDefines :
			self.myCxxFlags	+=	' -D' + define + ' '

		### configure compiler and linker flags.
		self.configureCxxFlagsAndLinkFlags( lenv )

		###### configure environment ######
		lenv['CXXFLAGS']	= self.myCxxFlags
		lenv['CPPPATH']	= self.myCppPath
		lenv['LINKFLAGS']	= self.myLinkFlags
		lenv['LIBPATH']	= self.myLibPath

		# configure lenv['LIBS'] with lenv['stdlibs']
		lenv['LIBS'] = lenv['stdlibs']

		# configure lenv['LIBS'] with lenv['libs']
		for lib in lenv['libs'] :
			libSplited	= string.split(lib, ' ')
			libExpanded = ''
			if ( len(libSplited) == 1 ) :
				libExpanded += lib + self.myPlatform_myCC + self.myPostfixLinkedToMyConfig
			elif ( len(libSplited) == 2 ) :
				libExpanded += libSplited[0] + self.myPlatform_myCC + '_' + libSplited[1] + self.myPostfixLinkedToMyConfig
			else:
				print 'sbfWarning: skip ', lib, ' because its name contains more than two spaces'

			lenv['LIBS'] += [libExpanded]

		# configure lenv[*] with lenv['uses']
		self.uses( lenv )

		###### setup 'pseudo BuildDir' (with OBJPREFIX) ######
		###										TODO: .cpp .cxx .c => config.options global, idem for pruneDirectories, .h .... => config.options global ?
		filesFromSrc		= []
		filesFromInclude	= []

		objFiles = []
		
		searchFiles( 'src', ['.*', 'DEBUG_*', 'RELEASE_*'], ['.cpp'], filesFromSrc )
		searchFiles( 'include', ['.*'], ['.hpp','.hxx','.h'], filesFromInclude )

		if		( self.myType == 'exec' or self.myType == 'static' ) :
			for srcFile in filesFromSrc :
				objFile				=	(os.path.splitext(srcFile)[0]).replace('src', self.myProjectBuildPathExpanded )
				srcFileExpanded	=	self.myProjectPathName + os.sep + srcFile
				objFiles	+=	lenv.Object( objFile, srcFileExpanded )				# Object is a synonym for the StaticObject builder method.
				### print objFile, ':', srcFileExpanded, '\n'

		elif	( self.myType == 'shared' ) :
			for srcFile in filesFromSrc :
				objFile				=	(os.path.splitext(srcFile)[0]).replace('src', self.myProjectBuildPathExpanded )
				srcFileExpanded	=	self.myProjectPathName + os.sep + srcFile
				objFiles	+=	lenv.SharedObject( objFile, srcFileExpanded )
				### print objFile, ':', srcFileExpanded, '\n'
		else :
			print 'sbfWarning: during setup of pseudo BuildDir'


		### final result of project ###
		objProject = self.myProjectBuildPathExpanded + os.sep + self.myProject + self.myPlatform_myCC
		if ( len(self.myPostfix) > 0 ) :
			objProject += '_' + self.myPostfix
		objProject += self.myPostfixLinkedToMyConfig

		#
		#projectTarget				= []

		installInBinTarget		= []
		installInIncludeTarget	= filesFromInclude
		installInLibTarget		= []

		if		( self.myType == 'exec' ) :
			projectTarget = lenv.Program( objProject, objFiles )
			installInBinTarget += projectTarget
		elif	( self.myType == 'static' ) :
			projectTarget = lenv.StaticLibrary( objProject, objFiles )
			installInLibTarget += projectTarget
		elif	( self.myType == 'shared' ) :
			projectTarget = lenv.SharedLibrary( objProject, objFiles )
			installInLibTarget += projectTarget
		else :
			print 'sbfWarning: during final setup of project'
		#																																			TODO: myType == 'headers'

		# projectTarget is not deleted before it is rebuilt.
		lenv.Precious( projectTarget )

		# PDB: pdb only generate on win32 and in debug mode.
		if (	(self.myPlatform == 'win32') and (self.myConfig == 'debug')	) :
		
			# PDB Generation
			# static library don't generate pdb.
			if		(self.myType == 'exec') or (self.myType == 'shared') :
				lenv['PDB'] = objProject + '.pdb'
				lenv.SideEffect(lenv['PDB'], projectTarget)
				# it is not deleted before it is rebuilt.
				lenv.Precious( lenv['PDB'] )

			# PDB Installation
			if		( self.myType == 'exec' ) :
				installInBinTarget.append(	File(objProject + '.pdb')	)
			elif	( self.myType == 'shared' ) :
				installInLibTarget.append(	File(objProject + '.pdb')	)


		######	setup targets : myProject_build myProject_install myProject myProject_clean myProject_mrproper ######

		### myProject_build
		env.Alias( self.myProject + '_build_print', lenv.Command('dummy_build_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
		env.Alias( self.myProject + '_build_print', lenv.Command('dummy_build_print' + self.myProject + 'out2', 'dummy.in', Action( nopAction, printBuild ) ) )
		env.AlwaysBuild( self.myProject + '_build_print' )

		aliasProjectBuild = env.Alias( self.myProject + '_build', self.myProject + '_build_print' )
		env.Alias( self.myProject + '_build', projectTarget )
		env.Clean( self.myProject + '_build', self.myProjectBuildPathExpanded  )

		### myProject_install

		installTarget	=	lenv.Install( self.myInstallDirectory + os.sep + 'bin',		installInBinTarget )
		
		for file in installInIncludeTarget :
			installTarget +=	lenv.InstallAs( self.myInstallDirectory + os.sep + file, self.myProjectPathName + os.sep + file )
		
		installTarget	+=	lenv.Install( self.myInstallDirectory + os.sep + 'lib',		installInLibTarget )

		env.Alias( self.myProject + '_install_print', lenv.Command('dummy_install_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printInstall ) ) )
		env.AlwaysBuild( self.myProject + '_install_print' )

		aliasProjectInstall = env.Alias( self.myProject + '_install', self.myProject + '_build' )
		env.Alias( self.myProject + '_install', self.myProject + '_install_print' )
		env.Alias( self.myProject + '_install', installTarget )

		### myProject
		aliasProject = env.Alias( self.myProject, aliasProjectInstall )

		### myProject_clean

		### FIXME																									printClean does'nt work ??? modified behavior when clean=1 ?
		#env.Alias( self.myProject + '_clean_print', lenv.Command('dummy_clean_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
		#env.Alias( self.myProject + '_clean_print', lenv.Command('dummy_clean_print' + self.myProject + 'out2', 'dummy.in', Action( nopAction, printClean ) ) )
		#env.AlwaysBuild( self.myProject + '_clean_print' )
		#env.Alias( self.myProject + '_clean', self.myProject + '_clean_print' )

		aliasProjectClean = env.Alias( self.myProject + '_clean', self.myProject + '_build' )

		### myProject_mrproper
		# FIXME: TODO: printMrproper see myProject_clean target.

		aliasProjectMrproper = env.Alias( self.myProject + '_mrproper', aliasProjectInstall )
		env.Clean( self.myProject + '_mrproper', self.myProjectBuildPath + os.sep + self.myProject )
		env.Clean( self.myProject + '_mrproper', self.myInstallDirectory + os.sep + 'include' + os.sep + self.myProject )

		###### special targets: build install all clean mrproper ######
		env.Alias( 'build', aliasProjectBuild )
		env.Alias( 'install', aliasProjectInstall )
		env.Alias( 'all', aliasProject )
		env.Alias( 'clean', aliasProjectClean )
		env.Alias( 'mrproper', aliasProjectMrproper )



###### Initial environment ######

# create objects
# HINTS: to propagate the entire external environment to the execution environment for commands : ENV = os.environ
env							=	Environment()
env['ENV']['PATH']		+=	os.environ['PATH']

#Export('env') not needed.
SConsEnvironment.sbf		= SConsBuildFramework()

# target 'sbfCheck'
Alias('sbfCheck')
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out1', 'dummy.in', Action( printCheckMessage, nopAction ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out2', 'dummy.in', Action( 'python -V' ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out3', 'dummy.in', Action( printEmptyLine, nopAction ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out4', 'dummy.in', Action( 'scons -v' ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out5', 'dummy.in', Action( printEmptyLine, nopAction ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out6', 'dummy.in', Action( checkCC, nopAction ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out7', 'dummy.in', Action( printEmptyLine, nopAction ) ) )
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out8', 'dummy.in', Action( checkSBF, nopAction ) ) )

# build 'caller' project (and all dependancies recursively)
env.sbf.buildProject( os.getcwd() )

env.Default( 'all' )
