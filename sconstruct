# SConsBuildFramework - Copyright (C) 2005, Nicolas Papier.
# Distributed under the terms of the GNU General Public License (GPL)
# as published by the Free Software Foundation.
# Author Nicolas Papier

# Installation : 
# --------------
#
# o Python 2.4 and up
# o SCons 0.96.90 and up
# o On Win32 platform : PySVN 1.1.2 for python 2.4 and svn 1.1.3 installation kit (py24-pysvn-svn113-1.1.2-347.exe)
#	On Debian\testing: Package python2.4-svn (1.1.2-3)
#
# SCONS_BUILD_FRAMEWORK environment variable must be set to the SConsBuildFramework root directory.
# It must be terminated by a '\' on windows platform and a '/' in all others one (for example: SCONS_BUILD_FRAMEWORK=D:\SConsBuildFramework\)
#
# The configuration of SBF is done by the file .SConsBuildFramework.options from $HOME directory. 
# If this file is not present then configuration is done with SConsBuildFramework.options from $SCONS_BUILD_FRAMEWORK directory.
#
# Features :
# ----------
#
# - list of targets:
#	- specific sbf target :
#		sbfCheck	:	print python, scons, CC and SBF version numbers, SCONS_BUILD_FRAMEWORK environment variable, and check if SCONS_BUILD_FRAMEWORK is well formed.
#	- svn targets:
#		svnCheckout or myProject_svnCheckout :
#				checkout missing project(s) from multiple svn repositories (i.e. when a project specified in dependencies does not exist 
#				on the filesystem, sbf try to checkout it from the first repository specified by svnUrls. If checkout fails, the next 
#				repository is used. And so on). myProject_svnCheckout target is used to checkout myProject. svnCheckout is used to checkout all projects.
#		svnUpdate or myProject_svnUpdate :
#				update project(s) from multiple svn repositories (sbf try to checkout it from the first repository specified by svnUrls. If checkout fails, the next 
#				repository is used. And so on).
#	- zip related targets :
#		zip			: a shortcut to 'zipRuntime zipDev zipSrc' targets detailed below.
#		zipRuntime	: create a package with binaries and libraries.
#		zipDev		: create a package with binaries, libraries and includes files.
#		zipSrc		: create a package with sources code files.
#
#   and myproject_build, myproject_install, myproject(idem myproject_install), myproject_clean, myproject_mrproper
#   and special targets build (for all myproject_build), install (for all myproject_install), all (for all myproject), clean (for all myproject_clean), mrproper (for all myproject_mrproper)
# - default target = all
# - projects dependencies (deps could be specified with name of project (search in parent directory), absolute path or relative path).
# - skip any missing projects (i.e. skip a project specified in dependencies but that don't exist on the filesystem).
#
# - build objects outside sources directories.
# - builded files could be shared among all the builds usings the same cache (see cachePath).
# - ...
#
# Rqs :
# -----
#
# - Spaces are not allowed in a project name.
# - installPaths, config and warningLevel are not used in default.options (only in SConsBuildFramework.options)
# ...



###### imports ######
import datetime
import distutils.archive_util
import fnmatch
import os
import re
import string
import sys

from SCons.Script.SConscript import SConsEnvironment
#import DumpEnv



###### Searching files in a filesystem ######
# Prune some directories
# Exclude/retain only a specific set of extensions for files
def searchFiles( searchDirectory, pruneDirectories, allowedExtensions, oFiles ) :
	for dirpath, dirnames, filenames in os.walk( searchDirectory, topdown=True ):
		# prune directories
		prune = []
		for pruneDirectory in pruneDirectories :
			prune.extend( fnmatch.filter(dirnames, pruneDirectory) )
		for x in prune:
			###print 'prune', x
			dirnames.remove( x )

		for file in filenames:
			for extension in allowedExtensions :
				if ( os.path.splitext(file)[1] == extension ) :
					pathfilename = os.path.join(dirpath,file)
					oFiles += [pathfilename]
					break

	###print 'oFiles=', oFiles


###### Svn ######
def svnCheckout( sbf ) :
	# try an svn checkout.
	import pysvn
	client = pysvn.Client()
	client.exception_style = 0

	for repository in sbf.mySvnUrls :
		svnUrl	= repository + '/' + sbf.myProject + '/trunk'
		print "sbfInfo: Try to check out a working copy from", svnUrl, ":"
		try :
			revision	= client.checkout(	url = svnUrl, path = sbf.myProjectPathName )
			entry		= client.info( sbf.myProjectPathName )
			print "sbfInfo:", sbf.myProject, "founded at", svnUrl
			if ( entry.revision.kind == pysvn.opt_revision_kind.number ) :
				print sbf.myProject, "at revision", entry.revision.number
			else :
				print sbf.myProject, "at revision", entry.revision.date
			return True
		except pysvn.ClientError, e :
			print str(e)
	else:
		return False


def svnUpdate( sbf ) :
	# try an svn update
	import pysvn
	client = pysvn.Client()
	client.exception_style = 0
	try :
		revision = client.update( sbf.myProjectPathName )
		if ( revision.kind == pysvn.opt_revision_kind.number ) :
			print sbf.myProject, "at revision", revision.number
		else :
			print sbf.myProject, "at revision", revision.date
		return True		
	except pysvn.ClientError, e :
		print str(e)
		return False


###### Archiver action ######
def zipArchiver( target, source, env ) :
	targetName = str(target[0])
	sourceName = str(source[0])
	distutils.archive_util.make_archive( targetName, 'zip', sourceName )

def printZipArchiver( target, source, env ) :
	targetName = str(target[0])
	sourceName = str(source[0])
	return "=> Create %s with files from %s" % (targetName, sourceName)


###### Action function for sbfCheck target #######
def sbfCheck(target = None, source = None, env = None) :
	print '----------------------- Check version -----------------------'
	
	env.Execute( 'python -V' )
	print
	
	print 'Version of python used by scons:', sys.version
	print
	
	env.Execute( 'scons -v' )
	print
	
	env.Execute( checkCC, nopAction )
	print

	print 'SConsBuildFramework 0.4'
	sbf_home = os.getenv('SCONS_BUILD_FRAMEWORK')
	print 'Environment variable SCONS_BUILD_FRAMEWORK=', sbf_home
	if ( len( sbf_home ) > 0 ) :
		if ( sbf_home[ len(sbf_home)-1 ] != os.sep ) :
			print 'sbfError: SCONS_BUILD_FRAMEWORK must be terminated by a directory separator !!!'
		else:
			print 'sbfInfo: SCONS_BUILD_FRAMEWORK is well formed.'
	else :
		print 'sbfError: SCONS_BUILD_FRAMEWORK must be defined or non empty !!!'


def checkCC(target = None, source = None, env = None) :
	if ( env['CC'] == 'cl' ) :
		#ccVersionAction		= Action( 'cl /help' )
		print env['CC'], ' --version '
		print 'cl ', env['MSVS']['VERSION']
	else :
		ccVersionAction		= Action( env['CC'] + ' -v' )
		env.Execute( ccVersionAction )


###### Print action function ######
def nopAction(target = None, source = None, env = None) :
	return 0

def printEmptyLine(target = None, source = None, env = None) :
	print ''

def printBuild( target, source, localenv ) :
	return "----------------------- Build %s -----------------------" % localenv['sbf_projectPathName']

def printInstall( target, source, localenv ) :
	return "-------------- Install %s files to %s ------------" % (localenv['sbf_projectPathName'], localenv.sbf.myInstallDirectory)

def printClean( target, source, localenv ) :
	return "-------------- Clean %s files to %s ------------" % (localenv['sbf_projectPathName'], localenv.sbf.myInstallDirectory)

def printMrproper( target, source, localenv ) :
	return "-------------- Mrproper %s files to %s ------------" % (localenv['sbf_projectPathName'], localenv.sbf.myInstallDirectory)

def printZip( target, source, localenv ) :
	return "----------------------- Create zip archives -----------------------"

def printRuntimeZip( target, source, localenv ) :
	return "-------------- Create runtime package ------------"

def printDevZip( target, source, localenv ) :
	return "-------------- Create dev package ------------"

def printSrcZip( target, source, localenv ) :
	return "-------------- Create src package ------------"


###### SConsBuildFramework class ######

class SConsBuildFramework :

	# global attributes from command line
	myBuildTargets					= set()
	#myGHasCleanOption				= False

	# globals attributes
	myPlatform						= ''
	myCC							= ''
	myPlatform_myCC					= ''
	myDate							= ''

	# global attributes from sbf.options or computed from sbf.options
	# from sbf.options
	mySvnUrls						= []
	mySvnCheckoutExclude			= []
	mySvnUpdateExclude				= []
	myInstallPaths					= []
	myBuildPath						= ''
	myCachePath						= ''
	myCacheOn						= False
	myConfig						= ''
	myWarningLevel					= ''
	# computed from sbf.options
	myInstallExtPaths				= []
	myInstallDirectory				= ''
	myGlobalCppPath					= []
	myGlobalLibPath					= []

	# project local attributes from default.options
	myDefines						= []
	myType							= ''
	myPostfix						= ''
	myDeps							= []
	myUses							= []
	myLibs							= []
	myStdlibs						= []

	# project local attributes
	myProjectPathName				= ''
	myProjectPath					= ''
	myProject						= ''
	myProjectBuildPath				= ''
	myPostfixLinkedToMyConfig		= ''

	myCxxFlags						= ''
	myCppPath						= []
	myLinkFlags						= ''
	myLibPath						= []

	myProjectBuildPathExpanded		= ''

	# list of projects that have been already parsed by scons
	myParsedProjects				= {}


	###### Constructor ######
	def __init__(self) :

		# read .SConsBuildFramework.options from HOME or SConsBuildFramework.options from SCONS_BUILD_FRAMEWORK.
		homeSConsBuildFrameworkOptions = os.path.expanduser('~/.SConsBuildFramework.options')

		if ( os.path.isfile(homeSConsBuildFrameworkOptions) ) :
			myOptions = self.readOptions( homeSConsBuildFrameworkOptions )
		else :
			myOptions = self.readOptions( os.path.join( os.getenv('SCONS_BUILD_FRAMEWORK'), 'SConsBuildFramework.options' ) )

		# update env and generate help
		myOptions.Update( env )
		Help( myOptions.GenerateHelpText(env) )

		# retrives all targets
		self.myBuildTargets = set( map(str, BUILD_TARGETS) )

		#self.myGHasCleanOption = env.GetOption('clean')

		# force clean=1 option if needed.
		if (	('clean' in self.myBuildTargets) or
				('mrproper' in self.myBuildTargets) ) :
			if ( len(self.myBuildTargets) != 1 ) :
				print 'sbfError: only one target allowed when using special target clean or mrproper'
				Exit( 1 )
			else :
				env.SetOption('clean', 1)

		# myPlatform, myCC and myPlatform_myCC
		# myPlatform = win32 | cygwin  | posix | darwin					FIXME: posix != linux and bsd ?, env['PLATFORM'] != sys.platform
		self.myPlatform			= env['PLATFORM']

		# myCC = clX-Y | gcc | env['CC']
		if		( env['CC'] == 'cl' ) :
			self.myCC = 'cl' + env['MSVS_VERSION'].replace('.','-')
		elif	( env['CC'] == 'g++') :
			self.myCC = 'gcc'
		else :
			self.myCC = env['CC']

		self.myPlatform_myCC = '_' + self.myPlatform + '_' + self.myCC

		# myDate
		self.myDate = str(datetime.date.today()).replace('-', '_')

		#
		self.initializeGlobalsFromEnv( env )


	###### Initialize global attributes ######
	def initializeGlobalsFromEnv( self, lenv ) :

		# update mySvnUrls, mySvnCheckoutExclude and mySvnUpdateExclude
		self.mySvnUrls				= lenv['svnUrls']
		self.mySvnCheckoutExclude	= lenv['svnCheckoutExclude']
		self.mySvnUpdateExclude		= lenv['svnUpdateExclude']

		# update myInstallPaths, myIntallExtPaths and myInstallDirectory
		self.myInstallPaths	= lenv['installPaths']

		self.myInstallExtPaths = []
		for element in self.myInstallPaths :
			self.myInstallExtPaths	+= [element + 'Ext' + self.myPlatform_myCC ]

		if ( len(self.myInstallPaths) >= 1 ) :
			self.myInstallDirectory	= self.myInstallPaths[0]
		else :
			print 'sbfError: empty installPaths'
			sys.exit()

		# update myBuildPath, myCachePath, myCacheOn, myConfig and myWarning
		self.myBuildPath	= lenv['buildPath']
		
		self.myCachePath	= lenv['cachePath']
		self.myCacheOn		= lenv['cacheOn']
		if (	(self.myCacheOn == True) and
				(len( self.myCachePath ) > 0 )	):
			env.CacheDir( self.myCachePath )
			print 'sbfInfo: Use cache ', self.myCachePath
		else :
			print 'sbfInfo: Don\'t use cache'
		
		self.myConfig			= lenv['config']
		self.myWarningLevel		= lenv['warningLevel']

		### use myInstallPaths to update myGlobalCppPath ###
		self.myGlobalCppPath = []
		for element in self.myInstallPaths :
			self.myGlobalCppPath	+= [element + os.sep + 'include']
			self.myGlobalCppPath	+= [element + 'Ext' + self.myPlatform_myCC + os.sep + 'include']

		### use myInstallPaths to update myGlobalLibPath ###
		self.myGlobalLibPath = []
		for element in self.myInstallPaths :
			self.myGlobalLibPath	+=	[element + os.sep + 'lib']
			self.myGlobalLibPath	+=	[element + 'Ext' + self.myPlatform_myCC + os.sep + 'lib']


	###### Initialize project from lenv ######
	def initializeProjectFromEnv( self, lenv ) :
		self.myDefines			= lenv['defines']
		self.myType				= lenv['type']
		self.myPostfix			= lenv['postfix']
		self.myDeps				= lenv['deps']
		self.myUses				= lenv['uses']
		self.myLibs				= lenv['libs']
		self.myStdlibs			= lenv['stdlibs']


	###### Initialize project ######
	def initializeProject( self, projectPathName ) :

		self.myProjectPathName	= projectPathName
		self.myProjectPath		= os.path.dirname( projectPathName )
		self.myProject			= os.path.basename(projectPathName)

		if ( os.path.isabs(self.myBuildPath) ) :
			self.myProjectBuildPath = os.path.abspath( self.myBuildPath )
		else :
			self.myProjectBuildPath = os.path.join( self.myProjectPathName, self.myBuildPath )

		if ( self.myConfig == 'debug' ) :										### TODO: not good if more than one config could be built
			self.myPostfixLinkedToMyConfig = '_D'
		else : 
			self.myPostfixLinkedToMyConfig = ''

		###
		self.myCxxFlags		= ''
		self.myCppPath		= [self.myProjectPathName + os.sep + 'include'] + self.myGlobalCppPath
		self.myLinkFlags	= ''
		self.myLibPath		= self.myGlobalLibPath


	###### Read a *.options file ######
	def readOptions( self, file ) :
		myOptions	= Options( file )
		myOptions.AddOptions(
			('svnUrls', 'Set the list of subversion repository used in order (from first to last) until a successful checkout occurs'),
			('svnCheckoutExclude', 'Set the list of project that may not be used for check out subversion operation. All projects not explicitly excluded will be included.'),
			('svnUpdateExclude', 'Set the list of project that may not be used for update subversion operation. All projects not explicitly excluded will be included.'),

			('installPaths', 'Set the list of search paths to \'/usr/local\' like directories. The first one would be used as a destination path for target named install'),

			('buildPath',	'Set the path to the directory in which to build all files (path could be absolute or relative to the project beiing build)', 'build' ),
			('cachePath',	'Set the path to cache that will be shared among all the builds using the same cachePath', ''),
			BoolOption('cacheOn', 'Set to use build cache.', False),

			EnumOption(	'config', 'Select a release or debug binary.', 'release',
							allowed_values=('debug', 'release'),
							map={}, ignorecase=2 ),
			EnumOption( 'warningLevel', 'Select level of warnings.', 'normal',
							allowed_values=('normal', 'high'),
							map={}, ignorecase=2 ),

			( 'defines', 'Set the list of predefined names (as a macro)'),
			EnumOption( 'type', 'Type of the target', 'exec',
							allowed_values=('exec', 'static','shared'),
							map={}, ignorecase=2 ),
			('postfix', 'Add a postfix to the target name'),

			('deps', 'Set dependencies to others projects (all dependencies are automatically built)'),

			('uses', 'Set usage of some predefined libraries (boost, opengl, openil, glu, glut, wx2-4, wxgl2-4)'),
			# (cg|cgFX|imageMagick6|imageMagick++6|itk)')
			#ListOption(	'uses', 'Set usage of some predefined libraries', 'none',
			#				['boost','opengl','openil','glu','glut','wx2-4','wxgl2-4'] ), # (cg|cgFX|imageMagick6|imageMagick++6|itk)')

			('libs', 'Set libraries used during the link stage that have been compiled with SConsBuildFramework (this scons system)'),
			('stdlibs', 'Set the standard libraries used during the link stage.')
								)
		return myOptions


	###### configure CxxFlags & LinkFlags ######
	def configureCxxFlagsAndLinkFlagsOnWin32( self, lenv ) :
	
		self.myCxxFlags += ' /nologo /GR /GX -DWIN32 -D_MBCS'								### /W3
		if ( self.myConfig == 'release' ) :													### TODO: use /Zd in release mode to be able to debug a little.
			self.myCxxFlags += ' -DNDEBUG /Zm600 /MD /O2 /TP '								### { /Gi ignored } and { /Og /Oi /Ot /Ob2 (in O2) }
		else :
			self.myCxxFlags += ' -D_DEBUG -DDEBUG /EHsc /MDd /Od'
			if '7' in lenv['MSVS']['VERSION'] :
				self.myCxxFlags += ' /Z7 '
			else :
				self.myCxxFlags += ' /Zi '
		if ( self.myWarningLevel == 'normal' ) :											### TODO: it is dependant of the myConfig. Must be changed ? yes, done...
			self.myCxxFlags += ' /W3 '
		else :
			self.myCxxFlags += ' /W4 '
			if '7' in lenv['MSVS']['VERSION'] :
				self.myCxxFlags += ' /Wp64 '
																							##/machine:I386
		self.myLinkFlags	+= ' /nologo /subsystem:windows /incremental:yes '				##/subsystem:console
		self.myCxxFlags		+= ' -D_WINDOWS '
																							## remove CONSOLE, MFC support, NOLIB
		# process myType
		if ( self.myType == 'exec' ) :
			self.myCxxFlags += ' /GA '
		else :
			if ( self.myType == 'shared' ) :
				self.myCxxFlags	+= ' -D_USRDLL '
				if '7' in lenv['MSVS']['VERSION'] :
					self.myCxxFlags += ' /G7 '
				else :
					self.myCxxFlags += ' /GD '												## remove Boundchecker support.


	def configureCxxFlagsAndLinkFlagsOnPosix( self, lenv ) :
	
		lenv['CXX'] = lenv.WhereIs('g++')													### myCxxFlags += ' -pedantic'
		if ( self.myConfig == 'release' ) :
			self.myCxxFlags	+= ' -DNDEBUG -O3 '												### TODO: more compiler arch-dependant optimization
		else :
			self.myCxxFlags	+= ' -D_DEBUG -DDEBUG -g -O0 '									### profiling myCxxFlags += ' -pg', mpatrol, leaktracer

		# process myWarningLevel, add always -Wall option.									### TODO: add more warnings with myWarningLevel = 'high' ?
		self.myCxxFlags	+= ' -Wall '


	def configureCxxFlagsAndLinkFlags( self, lenv ) :

		### complete myCxxFlags and myLinkFlags ###
		if ( self.myPlatform == 'win32' ) :
			self.configureCxxFlagsAndLinkFlagsOnWin32( lenv )
		elif ( self.myPlatform == 'cygwin' or self.myPlatform == 'posix' ) :
			self.configureCxxFlagsAndLinkFlagsOnPosix( lenv )
		else:
			print 'sbfWarning: unknown platform (', self.myPlatform, ')'

		# complete myCxxFlags with some defines
		if ( self.myType == 'shared' ) :
			self.myCxxFlags += ' -D' + self.myProject.upper() + '_EXPORTS '

		if ( sys.platform == 'darwin' ) :
			self.myCxxFlags += ' -D__MACOSX__'
		elif ( string.find( sys.platform, 'linux' ) != -1 ) :
			self.myCxxFlags += ' -D__linux'


	###### use_package (see option named 'uses') ######
	def use_boost( self, lenv, elt ) :
		if ( self.myPlatform != 'win32' ) :
			lenv['LIBS']	+= [	'boost_date_time-gcc-mt', 'boost_filesystem-gcc-mt', 'boost_regex-gcc-mt', 'boost_signals-gcc-mt', 'boost_thread-gcc-mt' ]
			#					[	'boost_date_time-gcc-mt', 'boost_filesystem-gcc-mt', 'boost_prg_exec_monitor-gcc-mt', 'boost_regex-gcc-mt',
			#						'boost_signals-gcc-mt', 'boost_test_exec_monitor-gcc-mt', 'boost_thread-gcc-mt', 'boost_unit_test_framework-gcc-mt' ]
		#else:
		# Nothing to do for win32 platform.

	def use_openIL( self, lenv, elt ) :
		if ( self.myPlatform == 'win32' ) :
			lenv['LIBS']	+= ['DevIL']
#			if ( self.myConfig == 'release' ) :																								### FIXME
#			else :
#				lenv['LIBS']	+= ['DevILd']
		else :
			lenv['LIBS']	+= ['IL']
#			if ( self.myConfig == 'release' ) :
#			else :
#				lenv['LIBS']	+= ['ILd']

	def use_wxWidgets( self, lenv, elt ) :
		if	( self.myPlatform == 'win32' ) :
			lenv['CXXFLAGS'] += ' -DWXUSINGDLL -D__WIN95__ '
			if ( (elt == 'wx2-4') or (elt == 'wxgl2-4') ) :
				if ( self.myConfig == 'release' ) :
						lenv['LIBS'] +=	['wxmsw24']
				else:
						lenv['LIBS'] +=	['wxmsw24d']
			else :
				print "sbfWarning: Unsupported version of wxWidgets"
		else :
			lenv['CXXFLAGS'] += ' -DGTK_NO_CHECK_CASTS -D__WXGTK__ -D_FILE_OFFSET_BITS=64 -D_LARGE_FILES '					### FIXME: bug in ParseConfig() ?
			if re.match('^wx[\d-]*$', elt ):
				env.ParseConfig('wx-config --prefix=' + os.path.join( self.myInstallExtPaths[0], 'lib' ) + ' --cppflags --ldflags --libs')
			else:
				env.ParseConfig('wx-config --prefix=' + os.path.join( self.myInstallExtPaths[0], 'lib' ) + ' --cppflags --ldflags --libs --gl-libs')

	def uses( self, lenv ) :
	
		for elt in lenv['uses'] :
			elt = string.lower( elt )
			
			### configure boost ###
			if ( elt == 'boost' ) :
				self.use_boost( lenv, elt )
	
			### configure OpenGL ###
			elif ( elt == 'opengl' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['opengl32']
				else :
					lenv['LIBS'] += ['GL']
	
			### configure openIL ###
			elif ( elt == 'openil' ) :
				self.use_openIL( lenv, elt )
	
			### configure glu ###
			elif ( elt == 'glu' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['glu32']
				else :
					lenv['LIBS'] += ['GLU']

			### configure glut ###
			elif ( elt == 'glut' ) :
				if		( self.myPlatform == 'win32' ) :
					lenv['LIBS'] += ['glut32']
				else :
					lenv['LIBS'] += ['glut']

			### configure wx* ###
			elif ( re.match('^wx[\d-]*$', elt ) or re.match('^wxgl[\d-]*$', elt ) ) :
				self.use_wxWidgets( lenv, elt )

			### configure others ? ###
			else :
				print "sbfWarning: unknown uses=[", elt, "']"


	###### Build a project ######
	def buildProject( self, projectPathName ) :

		self.myProjectPathName	= projectPathName
		self.myProject			= os.path.basename(projectPathName)

		# check if projectPathName is valid
		if ( os.path.isdir(projectPathName) == False ) :
			print "\nsbfWarning: Unable to find directory", self.myProjectPathName
			
			# What to do ?
			# a svn checkout ?
			if ( self.myProject not in self.mySvnCheckoutExclude ) :
				if (	('svnCheckout' in self.myBuildTargets) or
						(self.myProject+'_svnCheckout' in self.myBuildTargets)	) :
					print "----------------------- svn checkout %s -----------------------" % self.myProjectPathName
					successful = svnCheckout(self)
					if ( successful == False ) :
						print "sbfWarning: Unable to populate directory", self.myProjectPathName, "from svn. Skip to the next project..."
						return
					#else svn checkout done, continue.
				else :
					print "sbfWarning: None of targets svnCheckout or", self.myProject + "_svnCheckout have been specified. Skip to the next project..."
					return
			else :
				print "sbfWarning: Exclude from svn checkout. Skip to the next project..."
				return

		# check svnUpdate ?
		if ( self.myProject not in self.mySvnUpdateExclude ) :
			if (	('svnUpdate' in self.myBuildTargets) or
					(self.myProject+'_svnUpdate' in self.myBuildTargets)	) :
				print "----------------------- svn update %s -----------------------" % self.myProjectPathName
				successful = svnUpdate(self)
				if ( successful == False ) :
					print "sbfWarning: Unable to update directory", self.myProjectPathName, "from svn."
				#else svn update done, nothing to do
			#else nothing to do
		else :
			print "sbfWarning: Exclude from svn update."
		
		# configure a new environment and register it.
		lenv = env.Copy()
		self.myParsedProjects[self.myProject] = lenv

		# update lenv with build.options
		myBuildOptions = self.readOptions( projectPathName + os.sep + 'default.options' )
		myBuildOptions.Update( lenv )

		# construct dependencies
		for dep in lenv['deps'] :
			if ( dep not in self.myParsedProjects ) :
				# dep not already "build"
				if ( len(os.path.split(dep)[0]) == 0 ) :
					self.buildProject( os.path.abspath(os.path.join('../', dep)) )
				else :
					self.buildProject( os.path.abspath(dep) )
			#else nothing to do, project already "build"

		# initialize the project.
		self.initializeProjectFromEnv( lenv )
		self.initializeProject( projectPathName )

		# force clean=1 option if needed.
		if (	('clean' in self.myBuildTargets)					or
				('mrproper' in self.myBuildTargets)					or
				(self.myProject + '_clean' in self.myBuildTargets)	or
				(self.myProject + '_mrproper' in self.myBuildTargets ) ) :
			lenv.SetOption('clean', 1)

		# used by code printing messages during the different build stage.
		lenv['sbf_projectPathName'] = projectPathName
		
		os.chdir( projectPathName )																							# FIXME is chdir done at scons level ?

		# Dumping construction environment (for debugging).																	# TODO : a method printDebugInfo()
		#DumpEnv.DumpEnv( lenv )
		#print 'DEBUG:cwd=', os.getcwd()

		### construct project ###

		### expand myProjectBuildPathExpanded
		self.myProjectBuildPathExpanded = self.myProjectBuildPath + os.sep + self.myProject + os.sep + self.myPlatform + os.sep + self.myCC + os.sep + self.myConfig

		if ( len(self.myPostfix) > 0 ) :
			self.myProjectBuildPathExpanded += '_' + self.myPostfix

		### configure myCxxFlags with myDefines
		for define in self.myDefines :
			self.myCxxFlags	+=	' -D' + define + ' '

		### configure compiler and linker flags.
		self.configureCxxFlagsAndLinkFlags( lenv )

		###### configure environment ######
		lenv['CXXFLAGS']	= self.myCxxFlags
		lenv['CPPPATH']		= self.myCppPath
		lenv['LINKFLAGS']	= self.myLinkFlags
		lenv['LIBPATH']		= self.myLibPath

		# configure lenv['LIBS'] with lenv['stdlibs']
		lenv['LIBS'] = lenv['stdlibs']

		# configure lenv['LIBS'] with lenv['libs']
		for lib in lenv['libs'] :
			libSplited	= string.split(lib, ' ')
			libExpanded = ''
			if ( len(libSplited) == 1 ) :
				libExpanded += lib + self.myPlatform_myCC + self.myPostfixLinkedToMyConfig
			elif ( len(libSplited) == 2 ) :
				libExpanded += libSplited[0] + self.myPlatform_myCC + '_' + libSplited[1] + self.myPostfixLinkedToMyConfig
			else:
				print 'sbfWarning: skip ', lib, ' because its name contains more than two spaces'

			lenv['LIBS'] += [libExpanded]

		# configure lenv[*] with lenv['uses']
		self.uses( lenv )

		###### setup 'pseudo BuildDir' (with OBJPREFIX) ######
		###										TODO: .cpp .cxx .c => config.options global, idem for pruneDirectories, .h .... => config.options global ?
		filesFromSrc		= []
		filesFromInclude	= []

		searchFiles( 'src', ['.*', 'DEBUG_*', 'RELEASE_*'], ['.cpp'], filesFromSrc )
		searchFiles( 'include', ['.*'], ['.hpp','.hxx','.h'], filesFromInclude )

		objFiles = []
		if		( self.myType == 'exec' or self.myType == 'static' ) :
			for srcFile in filesFromSrc :
				objFile				=	(os.path.splitext(srcFile)[0]).replace('src', self.myProjectBuildPathExpanded )
				srcFileExpanded		=	self.myProjectPathName + os.sep + srcFile
				objFiles	+=	lenv.Object( objFile, srcFileExpanded )				# Object is a synonym for the StaticObject builder method.
				### print objFile, ':', srcFileExpanded, '\n'

		elif	( self.myType == 'shared' ) :
			for srcFile in filesFromSrc :
				objFile				=	(os.path.splitext(srcFile)[0]).replace('src', self.myProjectBuildPathExpanded )
				srcFileExpanded		=	self.myProjectPathName + os.sep + srcFile
				objFiles	+=	lenv.SharedObject( objFile, srcFileExpanded )
				### print objFile, ':', srcFileExpanded, '\n'
		else :
			print 'sbfWarning: during setup of pseudo BuildDir'


		### final result of project ###
		objProject = self.myProjectBuildPathExpanded + os.sep + self.myProject + self.myPlatform_myCC
		if ( len(self.myPostfix) > 0 ) :
			objProject += '_' + self.myPostfix
		objProject += self.myPostfixLinkedToMyConfig

		#
		installInBinTarget		= []
		installInIncludeTarget	= filesFromInclude
		installInLibTarget		= []

		if		( self.myType == 'exec' ) :
			projectTarget		=	lenv.Program( objProject, objFiles )
			installInBinTarget	+=	projectTarget
		elif	( self.myType == 'static' ) :
			projectTarget		=	lenv.StaticLibrary( objProject, objFiles )
			installInLibTarget	+=	projectTarget
		elif	( self.myType == 'shared' ) :
			projectTarget		=	lenv.SharedLibrary( objProject, objFiles )
			installInLibTarget	+=	projectTarget
		else :
			print 'sbfWarning: during final setup of project'
		#																												TODO: myType == 'headers'
		
		# projectTarget is not deleted before it is rebuilt.
		lenv.Precious( projectTarget )

		# PDB: pdb only generate on win32 and in debug mode.
		if (	(self.myPlatform == 'win32') and (self.myConfig == 'debug')	) :
		
			# PDB Generation
			# static library don't generate pdb.
			if		(self.myType == 'exec') or (self.myType == 'shared') :
				lenv['PDB'] = objProject + '.pdb'
				lenv.SideEffect(lenv['PDB'], projectTarget)
				# it is not deleted before it is rebuilt.
				lenv.Precious( lenv['PDB'] )

			# PDB Installation
			if		( self.myType == 'exec' ) :
				installInBinTarget.append(	File(objProject + '.pdb')	)
			elif	( self.myType == 'shared' ) :
				installInLibTarget.append(	File(objProject + '.pdb')	)


		######	setup targets : myProject_svnCheckout, myProject_svnUpdate, myProject_build myProject_install myProject myProject_clean myProject_mrproper ######

		### myProject_svnCheckout
		env.Alias( self.myProject + '_svnCheckout', env.Command('dummySvnCheckout.out1', 'dummy.in', Action( nopAction, nopAction ) ) )

		### myProject_svnUpdate
		env.Alias( self.myProject + '_svnUpdate', env.Command('dummySvnUpdate.out1', 'dummy.in', Action( nopAction, nopAction ) ) )
		
		### myProject_build
		env.Alias( self.myProject + '_build_print', lenv.Command('dummy_build_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
		env.Alias( self.myProject + '_build_print', lenv.Command('dummy_build_print' + self.myProject + 'out2', 'dummy.in', Action( nopAction, printBuild ) ) )
		env.AlwaysBuild( self.myProject + '_build_print' )

		aliasProjectBuild = env.Alias( self.myProject + '_build', self.myProject + '_build_print' )
		env.Alias( self.myProject + '_build', projectTarget )
		env.Clean( self.myProject + '_build', self.myProjectBuildPathExpanded  )

		### myProject_install
		installTarget	=	lenv.Install( self.myInstallDirectory + os.sep + 'bin',		installInBinTarget )
		
		for file in installInIncludeTarget :
			installTarget +=	lenv.InstallAs( self.myInstallDirectory + os.sep + file, self.myProjectPathName + os.sep + file )
		
		installTarget	+=	lenv.Install( self.myInstallDirectory + os.sep + 'lib',		installInLibTarget )

		#
		env.Alias( self.myProject + '_install_print', lenv.Command('dummy_install_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printInstall ) ) )
		env.AlwaysBuild( self.myProject + '_install_print' )

		aliasProjectInstall = env.Alias( self.myProject + '_install', self.myProject + '_build' )
		env.Alias( self.myProject + '_install', self.myProject + '_install_print' )
		env.Alias( self.myProject + '_install', installTarget )

		### myProject
		aliasProject = env.Alias( self.myProject, aliasProjectInstall )

		### myProject_clean

		### FIXME																									printClean does'nt work ??? modified behavior when clean=1 ?
		#env.Alias( self.myProject + '_clean_print', lenv.Command('dummy_clean_print' + self.myProject + 'out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
		#env.Alias( self.myProject + '_clean_print', lenv.Command('dummy_clean_print' + self.myProject + 'out2', 'dummy.in', Action( nopAction, printClean ) ) )
		#env.AlwaysBuild( self.myProject + '_clean_print' )
		#env.Alias( self.myProject + '_clean', self.myProject + '_clean_print' )

		aliasProjectClean = env.Alias( self.myProject + '_clean', self.myProject + '_build' )

		### myProject_mrproper
		# FIXME: TODO: printMrproper see myProject_clean target.

		aliasProjectMrproper = env.Alias( self.myProject + '_mrproper', aliasProjectInstall )
		env.Clean( self.myProject + '_mrproper', self.myProjectBuildPath + os.sep + self.myProject )
		env.Clean( self.myProject + '_mrproper', self.myInstallDirectory + os.sep + 'include' + os.sep + self.myProject )

		### TODO: myproject_zip
		
		### configure lenv
		
		lenv['sbf_include']	= filesFromInclude

		lenv['sbf_src']		= filesFromSrc

		lenv['sbf_lib']		= []
		for elt in installInLibTarget :
			## FIXME must be optimize.
			absPathFilename			= elt.abspath
			filename				= os.path.split(absPathFilename)[1]
			filenameExt				= os.path.splitext(filename)[1]
			if ( filenameExt == '.exp' ) :
				# exclude *.exp
				continue
			lenv['sbf_lib'] += [absPathFilename]

		lenv['sbf_bin'] = []
		for elt in installInBinTarget :
			lenv['sbf_bin'] += elt.abspath

		###### special targets: build install all clean mrproper ######
		env.Alias( 'build', aliasProjectBuild )
		env.Alias( 'install', aliasProjectInstall )
		env.Alias( 'all', aliasProject )
		env.Alias( 'clean', aliasProjectClean )
		env.Alias( 'mrproper', aliasProjectMrproper )



###### Initial environment ######

# create objects
# HINTS: to propagate the entire external environment to the execution environment for commands : ENV = os.environ
env						=	Environment()
env['ENV']['PATH']		+=	os.environ['PATH']

#Export('env') not needed.
SConsEnvironment.sbf	= SConsBuildFramework()

# target 'sbfCheck'
env.Alias('sbfCheck', env.Command('dummyCheckVersion.out1', 'dummy.in', Action( sbfCheck, nopAction ) ) )

# build 'caller' project (and all dependancies recursively)
env['sbf_projectPathName'] = os.getcwd()
env.sbf.buildProject( env['sbf_projectPathName'] )

env.Default( 'all' )

### special targets: svnCheckout svnUpdate ###
env.Alias( 'svnCheckout', env.Command('dummySvnCheckout.out1', 'dummy.in', Action( nopAction, nopAction ) ) )
env.Alias( 'svnUpdate', env.Command('dummySvnUpdate.out1', 'dummy.in', Action( nopAction, nopAction ) ) )

### special zip related targets : zipRuntime, zipDev, zipSrc and zip ###
if (	('zipRuntime'	in env.sbf.myBuildTargets) or
		('zipDev'		in env.sbf.myBuildTargets) or
		('zipSrc'		in env.sbf.myBuildTargets) or
		('zip'			in env.sbf.myBuildTargets)	) :
																							# FIXME: lazzy scons env construction => TODO: generalize (but must be optional)
	# Create a builder to zip files
	import SCons																			# from SCons.Script.SConscript import SConsEnvironment
	zipBuilder = env.Builder(	action=Action(zipArchiver,printZipArchiver),
								source_factory=SCons.Node.FS.default_fs.Entry,
								target_factory=SCons.Node.FS.default_fs.Entry,
								multi=0 )
	env['BUILDERS']['zipArchiver'] = zipBuilder

	#
	env.Alias( 'zip_print', env.Command('zip_print.out1', 'dummy.in', Action( nopAction, printEmptyLine ) ) )
	env.Alias( 'zip_print', env.Command('zip_print.out2', 'dummy.in', Action( nopAction, printZip ) ) )
	env.AlwaysBuild( 'zip_print' )
	
	env.Alias( 'runtimeZip_print', env.Command('runtimeZip_print.out2', 'dummy.in', Action( nopAction, printRuntimeZip ) ) )
	env.Alias( 'devZip_print', env.Command('devZip_print.out2', 'dummy.in', Action( nopAction, printDevZip ) ) )
	env.Alias( 'srcZip_print', env.Command('srcZip_print.out2', 'dummy.in', Action( nopAction, printSrcZip ) ) )

	env.Alias( 'zipRuntime', 'build' )
	env.Alias( 'zipRuntime', 'zip_print' )
	env.Alias( 'zipRuntime', 'runtimeZip_print' )
	env.Alias( 'zipDev', 'build' )	
	env.Alias( 'zipDev', 'zip_print' )
	env.Alias( 'zipDev', 'devZip_print' )
	env.Alias( 'zipSrc', 'zip_print' )
	env.Alias( 'zipSrc', 'srcZip_print' )

	# compute zipPath (where files are copying before creating the zip file)
	#/mnt/data/sbf/build/pak/gle_posix_gcc_0-3_D
	zipPath =	os.path.join( env.sbf.myBuildPath, 'pak', os.path.basename(env['sbf_projectPathName']))
	zipPath +=	env.sbf.myPlatform_myCC + '_' + env.sbf.myPostfix + env.sbf.myPostfixLinkedToMyConfig

	#_package_dev_2005_08_09
	runtimeZipPath	= zipPath + '_runtime_package_' + env.sbf.myDate
	devZipPath		= zipPath + '_dev_package_' + env.sbf.myDate
	srcZipPath		= zipPath + '_src_package_' + env.sbf.myDate

	# Collect files to create the zip
	runtimeZipFiles = []
	devZipFiles		= []
	srcZipFiles		= []

	for projectName in env.sbf.myParsedProjects :
		localenv = env.sbf.myParsedProjects[projectName]
		projectPathName	= localenv['sbf_projectPathName']
		project			= os.path.basename(projectPathName)
		
		runtimeZipFiles += env.Install(	os.path.join(runtimeZipPath, 'runtime'),	localenv['sbf_bin'] )
		runtimeZipFiles += env.Install(	os.path.join(runtimeZipPath, 'runtime'),	localenv['sbf_lib'] )

		devZipFiles += env.Install(		os.path.join(devZipPath, 'bin'),			localenv['sbf_bin'] )
		for file in localenv['sbf_include'] :
			devZipFiles += env.InstallAs(		os.path.join(devZipPath, file),		os.path.join(projectPathName, file) )
		devZipFiles += env.Install(				os.path.join(devZipPath, 'lib'),	localenv['sbf_lib'] )

		for file in localenv['sbf_src'] :
			srcZipFiles += env.InstallAs(		os.path.join(srcZipPath, project, file),		os.path.join(projectPathName, file) )	# FIXME: check if src/Object.hpp, defines Object in namespace project.

	runtimeZipFiles	+= env.zipArchiver( runtimeZipPath+'.zip', runtimeZipPath )
	devZipFiles		+= env.zipArchiver( devZipPath+'.zip', devZipPath )
	srcZipFiles		+= env.zipArchiver( srcZipPath+'.zip', srcZipPath )
	env.Alias( 'zipRuntime',	runtimeZipFiles )
	env.Alias( 'zipDev',		devZipFiles )
	env.Alias( 'zipSrc',		srcZipFiles )

	env.Alias( 'zip', ['zipRuntime', 'zipDev', 'zipSrc'] )
